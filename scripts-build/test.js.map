{"version":3,"sources":["webpack:///webpack/bootstrap 4a8d67f21900821aec86","webpack:///./scripts/test.js","webpack:///./~/tool-declare/declare.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA,oB;;;;;;mECJA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA2B,kEAAkE;;AAE7F;AACA;AACA,oCAAmC,iBAAiB,eAAe;AACnE;;AAEA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,oCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA4B,GAAG;AAC/B;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA,wCAAuC;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,cAAc,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,GAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA6C,OAAO;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,GAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,aAAa;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,cAAc,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,2BAA2B;AAChD;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC,G","file":"test.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4a8d67f21900821aec86\n **/","//引入toolDeclare模块\nvar toolDeclare = require('tool-declare');\nconsole.log(toolDeclare);\nconsole.log('2222');\nconsole.log('111');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/test.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\r\n * Created by rick on 14-5-16.\r\n */\r\nvar _ROOT;\r\nif(typeof window !== 'undefined'){\r\n\t_ROOT = window;\r\n}else{\r\n\t_ROOT = global;\r\n}\r\n(function(root, factory){\r\n    if (typeof define === 'function' && define.amd) {\r\n        // AMD\r\n        define(factory);\r\n    } else if (typeof exports === 'object') {\r\n        // Node, CommonJS-like\r\n        module.exports = factory();\r\n    } else {\r\n        // Browser globals (root is window)\r\n        root.declare = factory();\r\n    }\r\n}(this, function(){\r\n    if (_ROOT.__webpackage_declare) {\r\n        return _ROOT.__webpackage_declare;\r\n    }\r\n    var op = Object.prototype, opts = op.toString, xtor = new Function, counter = 0, cname='constructor';\r\n\r\n    var _extraNames = \"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor\".split(\".\");\r\n    var _extraLen = _extraNames.length;\r\n\r\n    function err(msg, cls){ throw new Error(\"declare\" + (cls ? \" \" + cls : \"\") + \": \" + msg); }\r\n\r\n// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)\r\n    function c3mro(bases, className){\r\n        var result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,\r\n            l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;\r\n\r\n        // build a list of bases naming them if needed\r\n        for(; i < l; ++i){\r\n            base = bases[i];\r\n            if(!base){\r\n                err(\"mixin #\" + i + \" is unknown. Did you use require to pull it in?\", className);\r\n            }else if(opts.call(base) != \"[object Function]\"){\r\n                err(\"mixin #\" + i + \" is not a callable constructor.\", className);\r\n            }\r\n            lin = base._meta ? base._meta.bases : [base];\r\n            top = 0;\r\n            // add bases to the name map\r\n            for(j = lin.length - 1; j >= 0; --j){\r\n                proto = lin[j].prototype;\r\n                if(!proto.hasOwnProperty(\"declaredClass\")){\r\n                    proto.declaredClass = \"uniqName_\" + (counter++);\r\n                }\r\n                name = proto.declaredClass;\r\n                if(!nameMap.hasOwnProperty(name)){\r\n                    nameMap[name] = {count: 0, refs: [], cls: lin[j]};\r\n                    ++clsCount;\r\n                }\r\n                rec = nameMap[name];\r\n                if(top && top !== rec){\r\n                    rec.refs.push(top);\r\n                    ++top.count;\r\n                }\r\n                top = rec;\r\n            }\r\n            ++top.count;\r\n            roots[0].refs.push(top);\r\n        }\r\n\r\n        // remove classes without external references recursively\r\n        while(roots.length){\r\n            top = roots.pop();\r\n            result.push(top.cls);\r\n            --clsCount;\r\n            // optimization: follow a single-linked chain\r\n            while(refs = top.refs, refs.length == 1){\r\n                top = refs[0];\r\n                if(!top || --top.count){\r\n                    // branch or end of chain => do not end to roots\r\n                    top = 0;\r\n                    break;\r\n                }\r\n                result.push(top.cls);\r\n                --clsCount;\r\n            }\r\n            if(top){\r\n                // branch\r\n                for(i = 0, l = refs.length; i < l; ++i){\r\n                    top = refs[i];\r\n                    if(!--top.count){\r\n                        roots.push(top);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if(clsCount){\r\n            err(\"can't build consistent linearization\", className);\r\n        }\r\n\r\n        // calculate the superclass offset\r\n        base = bases[0];\r\n        result[0] = base ?\r\n            base._meta && base === result[result.length - base._meta.bases.length] ?\r\n                base._meta.bases.length : 1 : 0;\r\n\r\n        return result;\r\n    }\r\n\r\n    function declare(className, superclass, props) {\r\n        if (typeof className != \"string\") {\r\n            props = superclass;\r\n            superclass = className;\r\n            className = \"\";\r\n        }\r\n        props = props || [];\r\n\r\n        var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;\r\n\r\n        if(opts.call(superclass) == \"[object Array]\"){\r\n            bases = c3mro(superclass, className);\r\n            t = bases[0];\r\n            mixins = bases.length - t;\r\n            superclass = bases[mixins];\r\n        } else {\r\n            bases = [0];\r\n            if(superclass){\r\n                if(opts.call(superclass) == \"[object Function]\"){\r\n                    t = superclass._meta;\r\n                    bases = bases.concat(t ? t.bases : superclass);\r\n                }else{\r\n                    err(\"base class is not a callable constructor.\", className);\r\n                }\r\n            }else if(superclass !== null){\r\n                err(\"unknown base class. Did you use require to pull it in?\", className);\r\n            }\r\n        }\r\n\r\n        if (superclass) {\r\n            for (i = mixins - 1;; --i) {\r\n                proto = forceNew(superclass);\r\n                if (!i) {\r\n                    break;\r\n                }\r\n                // mix in properties\r\n                t = bases[i];\r\n                (t._meta ? mixOwn : mixin)(proto, t.prototype);\r\n                // chain in new constructor\r\n                ctor = new Function;\r\n                ctor.superclass = superclass;\r\n                ctor.prototype = proto;\r\n                superclass = proto.constructor = ctor;\r\n            }\r\n        } else {\r\n            proto = {};\r\n        }\r\n\r\n        safeMixin(proto, props);\r\n\r\n        t = props.constructor;\r\n        if (t !== op.constructor) {\r\n            t.nom = cname;\r\n            proto.constructor = t;\r\n        }\r\n\r\n        for (i = mixins - 1; i; --i) {\r\n            t = bases[i]._meta;\r\n            if(t && t.chains){\r\n                chains = mixin(chains || {}, t.chains);\r\n            }\r\n        }\r\n        if(proto[\"-chains-\"]){\r\n            chains = mixin(chains || {}, proto[\"-chains-\"]);\r\n        }\r\n\r\n        t = !chains || !chains.hasOwnProperty(cname);\r\n        bases[0] = ctor = (chains && chains.constructor === \"manual\") ? simpleConstructor(bases) :\r\n            (bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));\r\n//        bases[0] = ctor = bases.length == 1 ? singleConstructor(props.constructor, true) : chainedConstructor(bases, true);\r\n\r\n        ctor._meta = {\r\n            bases : bases,\r\n            hidden : props,\r\n            chains : chains,\r\n            parents : parents,\r\n            ctor : props.constructor\r\n        };\r\n        ctor.superclass = superclass && superclass.prototype;\r\n        ctor.extend = extend;\r\n        ctor.prototype = proto;\r\n        proto.constructor = ctor;\r\n\r\n        proto.inherited = inherited;\r\n\r\n        if (className) {\r\n            proto.delcaredClass = className;\r\n        }\r\n\r\n        if(chains){\r\n            for(name in chains){\r\n                if(proto[name] && typeof chains[name] == \"string\" && name != cname){\r\n                    t = proto[name] = chain(name, bases, chains[name] === \"after\");\r\n                    t.nom = name;\r\n                }\r\n            }\r\n        }\r\n        return ctor;\r\n    }\r\n\r\n// forceNew(ctor)\r\n// return a new object that inherits from ctor.prototype but\r\n// without actually running ctor on the object.\r\n    function forceNew(ctor){\r\n        // create object with correct prototype using a do-nothing\r\n        // constructor\r\n        xtor.prototype = ctor.prototype;\r\n        var t = new xtor;\r\n        xtor.prototype = null;\t// clean up\r\n        return t;\r\n    }\r\n\r\n// applyNew(args)\r\n// just like 'new ctor()' except that the constructor and its arguments come\r\n// from args, which must be an array or an arguments object\r\n    function applyNew(args){\r\n        // create an object with ctor's prototype but without\r\n        // calling ctor on it.\r\n        var ctor = args.callee, t = forceNew(ctor);\r\n        // execute the real constructor on the new object\r\n        ctor.apply(t, args);\r\n        return t;\r\n    }\r\n\r\n    function singleConstructor(ctor, ctorSpecial){\r\n        return function() {\r\n            var a = arguments, t = a, a0 = a[0], f;\r\n\r\n            if (!(this instanceof a.callee)) {\r\n                return applyNew(a);\r\n            }\r\n\r\n            if(ctorSpecial){\r\n                // full blown ritual\r\n                if(a0){\r\n                    // process the preamble of the 1st argument\r\n                    f = a0.preamble;\r\n                    if(f){\r\n                        t = f.apply(this, t) || t;\r\n                    }\r\n                }\r\n                f = this.preamble;\r\n                if(f){\r\n                    // process the preamble of this class\r\n                    f.apply(this, t);\r\n                    // one peculiarity of the preamble:\r\n                    // it is called even if it is not needed,\r\n                    // e.g., there is no constructor to call\r\n                    // let's watch for the last constructor\r\n                    // (see ticket #9795)\r\n                }\r\n            }\r\n\r\n            if (ctor) {\r\n                ctor.apply(this, a);\r\n            }\r\n\r\n            f = this.postscript;\r\n            if(f){\r\n                f.apply(this, a);\r\n            }\r\n        };\r\n    }\r\n\r\n    function chainedConstructor(bases, ctorSpecial){\r\n        return function(){\r\n            var a = arguments, args = a, a0 = a[0], f, i, m,\r\n                l = bases.length, preArgs;\r\n\r\n            if(!(this instanceof a.callee)){\r\n                // not called via new, so force it\r\n                return applyNew(a);\r\n            }\r\n\r\n            //this._inherited = {};\r\n            // perform the shaman's rituals of the original declare()\r\n            // 1) call two types of the preamble\r\n            if(ctorSpecial && (a0 && a0.preamble || this.preamble)){\r\n                // full blown ritual\r\n                preArgs = new Array(bases.length);\r\n                // prepare parameters\r\n                preArgs[0] = a;\r\n                for(i = 0;;){\r\n                    // process the preamble of the 1st argument\r\n                    a0 = a[0];\r\n                    if(a0){\r\n                        f = a0.preamble;\r\n                        if(f){\r\n                            a = f.apply(this, a) || a;\r\n                        }\r\n                    }\r\n                    // process the preamble of this class\r\n                    f = bases[i].prototype;\r\n                    f = f.hasOwnProperty(\"preamble\") && f.preamble;\r\n                    if(f){\r\n                        a = f.apply(this, a) || a;\r\n                    }\r\n                    // one peculiarity of the preamble:\r\n                    // it is called if it is not needed,\r\n                    // e.g., there is no constructor to call\r\n                    // let's watch for the last constructor\r\n                    // (see ticket #9795)\r\n                    if(++i == l){\r\n                        break;\r\n                    }\r\n                    preArgs[i] = a;\r\n                }\r\n            }\r\n            // 2) call all non-trivial constructors using prepared arguments\r\n            for(i = l - 1; i >= 0; --i){\r\n                f = bases[i];\r\n                m = f._meta;\r\n                f = m ? m.ctor : f;\r\n                if(f){\r\n                    f.apply(this, preArgs ? preArgs[i] : a);\r\n                }\r\n            }\r\n            // 3) continue the original ritual: call the postscript\r\n            f = this.postscript;\r\n            if(f){\r\n                f.apply(this, args);\r\n            }\r\n        };\r\n    }\r\n\r\n    function simpleConstructor(bases){\r\n        return function(){\r\n            var a = arguments, i = 0, f, m;\r\n\r\n            if(!(this instanceof a.callee)){\r\n                // not called via new, so force it\r\n                return applyNew(a);\r\n            }\r\n\r\n            //this._inherited = {};\r\n            // perform the shaman's rituals of the original declare()\r\n            // 1) do not call the preamble\r\n            // 2) call the top constructor (it can use this.inherited())\r\n            for(; f = bases[i]; ++i){ // intentional assignment\r\n                m = f._meta;\r\n                f = m ? m.ctor : f;\r\n                if(f){\r\n                    f.apply(this, a);\r\n                    break;\r\n                }\r\n            }\r\n            // 3) call the postscript\r\n            f = this.postscript;\r\n            if(f){\r\n                f.apply(this, a);\r\n            }\r\n        };\r\n    }\r\n\r\n    function safeMixin(target, source) {\r\n        var name, t;\r\n        // add props adding metadata for incoming functions skipping a constructor\r\n        for(name in source){\r\n            t = source[name];\r\n            if((t !== op[name] || !(name in op)) && name != cname){\r\n                if(opts.call(t) == \"[object Function]\"){\r\n                    // non-trivial function method => attach its name\r\n                    t.nom = name;\r\n                }\r\n                target[name] = t;\r\n            }\r\n        }\r\n        if(hasBugForInSkip()){\r\n            for(var i= _extraLen; i;){\r\n                name = _extraNames[--i];\r\n                t = source[name];\r\n                if((t !== op[name] || !(name in op)) && name != cname){\r\n                    if(opts.call(t) == \"[object Function]\"){\r\n                        // non-trivial function method => attach its name\r\n                        t.nom = name;\r\n                    }\r\n                    target[name] = t;\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function mixin(target, sources) {\r\n        target = target || {};\r\n        for (var i = 1, l = arguments.length; i < l; ++i) {\r\n            _mixin(target, arguments[i]);\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function _mixin(dest, source) {\r\n        var name, s, i, empty = {};\r\n        for(name in source){\r\n            // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in \"source\"\r\n            // inherited from Object.prototype.\t For example, if dest has a custom toString() method,\r\n            // don't overwrite it with the toString() method that source inherited from Object.prototype\r\n            s = source[name];\r\n            if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\r\n                dest[name] = s;\r\n            }\r\n        }\r\n\r\n        if(hasBugForInSkip()){\r\n            if(source){\r\n                for(i = 0; i < _extraLen; ++i){\r\n                    name = _extraNames[i];\r\n                    s = source[name];\r\n                    if(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\r\n                        dest[name] = s;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return dest; // Object\r\n    }\r\n\r\n    function mixOwn(target, source) {\r\n        // add props adding metadata for incoming functions skipping a constructor\r\n        for(var name in source){\r\n            if(name != cname && source.hasOwnProperty(name)){\r\n                target[name] = source[name];\r\n            }\r\n        }\r\n        if(hasBugForInSkip()){\r\n            for(var i= _extraLen; i;){\r\n                name = _extraNames[--i];\r\n                if(name != cname && source.hasOwnProperty(name)){\r\n                    target[name] = source[name];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function extend(source){\r\n        declare.safeMixin(this.prototype, source);\r\n        return this;\r\n    }\r\n\r\n    function hasBugForInSkip() {\r\n        for (var i in {toString : 1}) {\r\n            return 0;\r\n        }\r\n        return 1;\r\n    }\r\n\r\n    function chain(name, bases, reversed){\r\n        return function(){\r\n            var b, m, f, i = 0, step = 1;\r\n            if(reversed){\r\n                i = bases.length - 1;\r\n                step = -1;\r\n            }\r\n            for(; b = bases[i]; i += step){ // intentional assignment\r\n                m = b._meta;\r\n                f = (m ? m.hidden : b.prototype)[name];\r\n                if(f){\r\n                    f.apply(this, arguments);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    function inherited(args, a, f){\r\n        var name, chains, bases, caller, meta, base, proto, opf, pos,\r\n            cache = this._inherited = this._inherited || {};\r\n\r\n        // crack arguments\r\n        if(typeof args == \"string\"){\r\n            name = args;\r\n            args = a;\r\n            a = f;\r\n        }\r\n        f = 0;\r\n\r\n        caller = args.callee;\r\n        name = name || caller.nom;\r\n        if(!name){\r\n            err(\"can't deduce a name to call inherited()\", this.declaredClass);\r\n        }\r\n\r\n        meta = this.constructor._meta;\r\n        bases = meta.bases;\r\n\r\n        pos = cache.p;\r\n        if(name != cname){\r\n            // method\r\n            if(cache.c !== caller){\r\n                // cache bust\r\n                pos = 0;\r\n                base = bases[0];\r\n                meta = base._meta;\r\n                if(meta.hidden[name] !== caller){\r\n                    // error detection\r\n                    chains = meta.chains;\r\n                    if(chains && typeof chains[name] == \"string\"){\r\n                        err(\"calling chained method with inherited: \" + name, this.declaredClass);\r\n                    }\r\n                    // find caller\r\n                    do{\r\n                        meta = base._meta;\r\n                        proto = base.prototype;\r\n                        if(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){\r\n                            break;\r\n                        }\r\n                    }while(base = bases[++pos]); // intentional assignment\r\n                    pos = base ? pos : -1;\r\n                }\r\n            }\r\n            // find next\r\n            base = bases[++pos];\r\n            if(base){\r\n                proto = base.prototype;\r\n                if(base._meta && proto.hasOwnProperty(name)){\r\n                    f = proto[name];\r\n                }else{\r\n                    opf = op[name];\r\n                    do{\r\n                        proto = base.prototype;\r\n                        f = proto[name];\r\n                        if(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){\r\n                            break;\r\n                        }\r\n                    }while(base = bases[++pos]); // intentional assignment\r\n                }\r\n            }\r\n            f = base && f || op[name];\r\n        }else{\r\n            // constructor\r\n            if(cache.c !== caller){\r\n                // cache bust\r\n                pos = 0;\r\n                meta = bases[0]._meta;\r\n                if(meta && meta.ctor !== caller){\r\n                    // error detection\r\n                    chains = meta.chains;\r\n                    if(!chains || chains.constructor !== \"manual\"){\r\n                        err(\"calling chained constructor with inherited\", this.declaredClass);\r\n                    }\r\n                    // find caller\r\n                    while(base = bases[++pos]){ // intentional assignment\r\n                        meta = base._meta;\r\n                        if(meta && meta.ctor === caller){\r\n                            break;\r\n                        }\r\n                    }\r\n                    pos = base ? pos : -1;\r\n                }\r\n            }\r\n            // find next\r\n            while(base = bases[++pos]){\t// intentional assignment\r\n                meta = base._meta;\r\n                f = meta ? meta.ctor : base;\r\n                if(f){\r\n                    break;\r\n                }\r\n            }\r\n            f = base && f;\r\n        }\r\n\r\n        // cache the found super method\r\n        cache.c = f;\r\n        cache.p = pos;\r\n\r\n        // now we have the result\r\n        if(f){\r\n            return a === true ? f : f.apply(this, a || args);\r\n        }\r\n        // intentionally no return if a super method was not found\r\n    }\r\n\r\n    declare.safeMixin = safeMixin;\r\n    declare.mixin = mixin;\r\n    _ROOT.__webpackage_declare = declare;\r\n    return declare;\r\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/tool-declare/declare.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}